### 进程管理
  + 程序、进程、作业概念和区别
    + **程序**:`静态概念，只要不被破坏就会一直存在`
    + **进程**:`动态概念，创建而产生，撤销而消亡`
    + 没有程序也就没有进程
    + **进程**是运行过程中的程序
    + **进程**是程序在某个数据集合上的一次执行过程、具有并发性和动态性
    + **进程**由`进程控制块PCB`、`程序段`、`数据空间`等三部分组成
    + **进程控制**是通过进程控制原语实现的
      > 用户通过**系统调用接口**调用**进程控制原语**实现进程的**建立**和**撤销**、**阻塞**、**唤醒**等功能
    + **进程**是竞争计算机系统有限资源的**基本单位**，也是进程处理机调度的基本单位
    + **进程和作业的关系**
      * 作业是用户向计算机提交任务的任务实体<br>
        在用户向计算机提交作业后，系统将它放入外存中的作业等待队列中等待执行<br>
        而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位<br>
        任一进程，只要它被创建，总有相应的部分存在于内存中<br>
      * 一个作业可由多个进程组成，且必须至少由一个进程组成，反过来则不成立
      * 作业的概念主要用在批处理系统中，像UNIX这样的分时系统中就没有作业的概念<br>
        而进程的概念则用在几乎所有的多道程序系统中
  + 进程的状态
    + 三态模型
      ![4-4](https://github.com/flysafely/Software-Design-Engineer-Note/blob/master/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/%E6%9C%AC%E7%AB%A0%E5%9B%BE%E7%A4%BA/4-4.jpg)
      + 就绪状态
        > 被CPU调度进入运行状态<br>
          **唤醒**可以又用户进程发起
      + 运行状态
        > CPU时间片 用完返回就绪状态<br>
          调度和超时都是操作系统自动控制
      + 等待状态(阻塞状态)
        > 等待的时间发生了，进入就绪状态
      > 只有就绪状态和运行状态可以相互转换
    + 五态模型
      ![4-5](https://github.com/flysafely/Software-Design-Engineer-Note/blob/master/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/%E6%9C%AC%E7%AB%A0%E5%9B%BE%E7%A4%BA/4-5.jpg)
      + **新建状态**
      + 就绪状态
      + 运行状态
      + 等待状态
      + **终止状态**
    + 具有挂起状态的进程
      + 活跃就绪
      + 静止就绪
      + 活跃阻塞
      + 静止阻塞
  ---
  + 同步和互斥★★★
    + 同步:合作进程间的直接制约
    + 互斥:进程间申请临界资源的间接制约
    + 信号量**S**
      + 物理意义
        > S>=0:某资源的可用数<br>
          S<0:其绝对值表示阻塞队列中的等待该资源的进程数
      + **PV**操作
        + 特点:`成对出现，执行期间不可分离`
        + P操作:申请一个资源
          > 例如:P(S<sub>1</sub>)申请一个S<sub>1</sub>资源<br>
            先执行S=S-1，当执行完减操作后:<br>
            > 若S>=0，执行P操作的进程继续执行<br>
            > 若S<0，置该进程为阻塞状态，并将其插入阻塞队列
            
        + V操作:释放一个资源
          > 例如:V(S<sub>1</sub>)释放一个S<sub>1</sub>资源<br>
            先执行S=S+1，当执行完加操作后:<br>
            > 若S>0，执行V操作的进程继续执行<br>
            > 若S<=0，从阻塞队列唤醒一个进程，插入就绪队列，然后执行V操作的进程继续
        + 理解:
          > PV操作是一个流程的向下流程进行的判断开关，例如P(S)  S=S-1 如果S<0了，流程就不能继续往下了
  ---
  + 管程
    + 避免分散编程的困难
    + 数据结构抽象共享资源
    + 集中管理共享资源
  + 进程调度
    + 可剥夺：`CPU立即执行更高优先级进程`
    + 不可剥夺：`CPU待正在运行进程释放后，运行更高优先级进程`
    + **三级调度**
      + 高级调度:`一个作业只需经过一次，调入系统做好准备`
      + 中级调度:`决定哪些就绪进程可以调入内存参与CPU竞争`
      + 低级调度:`内存中哪些就绪进程可以占用CPU`
    + 调度算法:
      + 先来先服务FCFS
      + 时间片轮转
        + 固定时间片
        + 可变时间片
      + 优先级调度
        + 静态优先级
        + 动态优先级
      + 多级反馈调度
    + 进程优先级确认
      + I/O型:高优先级，小时间片，及时响应避免卡死
      + CPU型:逐步降低优先级，增大时间片
      + I/O型少和CPU型多:先完成I/O，直接进入 I/O完成时所在队列
  ---
  + 死锁★★★
    + 概念
      > 两个以上进程互相要求已经被占用的资源而导致无法继续运行<br>
        发生死锁，在进程资源有向图必定构成了环路
    + 产生条件
      + 互斥条件
      + 请求保持条件
      + 不可剥夺条件
    + 死锁的处理
      + 鸵鸟策略（不予理睬）
      + 预防策略
        + 预先静态分配法：`破坏“不可剥夺条件”`
        + 资源有序分配：`破坏“环路条件”`
      + 避免策略
        + [银行家算法(视频最后部分)](https://pan.baidu.com/play/video#/video?path=%2F%E8%B5%84%E6%BA%90%2F%E8%BD%AF%E8%80%83%E6%95%99%E7%A8%8B%2F2018%E5%B9%B4%E8%B5%84%E6%96%99%2F0%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E4%B9%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%2F%E8%A7%86%E9%A2%91%E5%92%8C%E8%AF%BE%E4%BB%B6%2F%E7%8E%8B%E5%AF%84%E6%B8%85%EF%BC%8C%E7%AC%AC%E4%BA%94%E7%89%88%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%2F%E7%AC%AC%202%20%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E7%AC%AC1%E8%8A%82%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86_recv.mp4&t=-1)
          > 算法开销较大
      + 死锁检测
      + 死锁解除
        + 资源剥夺法
        + 撤销进程法
  ---
  + [线程](https://www.jianshu.com/p/68720001b81d)
